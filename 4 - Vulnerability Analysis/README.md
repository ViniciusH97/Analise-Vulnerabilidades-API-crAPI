# Análise de Vulnerabilidades

O objetivo desta etapa é identificar possíveis brechas/falhas nos endpoints identificados na fase anterior. Apenas para indicar os possíveis vetores para que em seguida seja explorado na fase [Intelligence Gathering](https://github.com/ViniciusH97/Analise-Vulnerabilidades-API-crAPI/tree/main/2%20-%20Intelligence%20Gathering) para validar se possuem risco de vazamento de dados e informações.

Será validado conforme as vulnerabilidades classficadas pela OWASP.

## Ferramentas utilizadas

- **Burp Suite:** Interceptação por Proxy, repetição (Repeater) e automação (Intruder).

- **Postman:** Organização e envio de requisições-base.

- **Contas de Teste:**

        Usuário A: usuario1@gmail.com

        Usuario B: usuario2@gmail.com

## Análise de Vulnerabilidades de Endpoints:

Endpoints que envolve Autenticação do usuário:

Os endpoints abaixo pode ser usado por um atacante para se passar por outra pessoa e conseguir informações das mesmas.

### Análise do endpoint: `POST /identity/api/auth/login`

Foi feito requisições com email e senha invalidos e foi possivel obter as seguintes respostas no endpoint `identity/api/auth/login`:

1. **E-mail correto e senha incorreta:** O endpoint retorna a mensagem `Invalid Credentials`.
2. **E-mail e senha incorreta:** O endpoint retorna a mensagem `Given a E-mail is not registered`.

Após a análise foi possível identificar respostas diferentes para cada caso. Quando o e-mail é válido e a senha é inválide, e quanto do e-mail e senha são invalidos. O retorno de credenciais inválidas e que o e-mail não está cadastrado facilita ao atacante realizar uma enumeração de usuários, ou seja, pode aplicar um ataque dicionário, esperando as resposta das requisições `Invalid Credentials`, fornecendo a informação que o e-mail está cadastrado mas a senha não é válida, caso contrário, se retornar `Given a E-mail not registered` significa que o e-mail não está cadastrado no banco de dados.

**Evidências do teste com o e-mail válido e senha inválida**

<img width="855" height="568" alt="image" src="https://github.com/user-attachments/assets/4faf631d-5634-49f6-bb96-913b06ad71c6" />

**Evidência do teste com o e-mail inválido e senha inválida**

<img width="905" height="568" alt="image" src="https://github.com/user-attachments/assets/157acb28-8924-4730-9e8c-39851c506bc4" />


O ultimo caso é o teste com e-mail e senha válidos, nesse casos é retornado o token no próprio `response` após a requisição da API. 

<img width="732" height="561" alt="image" src="https://github.com/user-attachments/assets/92539a51-9860-412c-b26e-b7885035d92d" />

Ao coletar o token, o próximo passo foi analisar o token de autenticação na ferramenta [jwt.io](https://www.jwt.io/), com ele foi possível visualizar o Header e o Payload, como podemos ver na imagem abaixo:


<img width="1231" height="609" alt="jwt io" src="https://github.com/user-attachments/assets/a2669c9b-c505-4605-8ab2-cce2358bd5a3" />


Segundo a imagem podemos ver o campo `"alg": "RS256"`, esse campo demonstra que o token é assinado usando o algoritmo chamado de RS256. Este é um algoritmo de criptografia assimétrica, ou seja, possui um par de chaves, uma chave privada é usada assinar o token e uma chave pública para validar a autenticidade do token.

O outro campo é do payload:

- `"sub": "usuario1@gmail.com"`: O "subject" do token, que identifica o usuário como "usuario1@gmail.com". 
- `"iat": 1761328882`: O "issued at" (emitido em), um carimbo de data/hora (timestamp) de quando o token foi criado.
- `"exp": 1761933682`: O "expiration" (expiração), o timestamp de quando o token deixará de ser válido.
- `"role": "user":` Um campo personalizado (claim) que identifica o nível de privilégio do usuário, nesse caso está como "user".

Esse token está normal. A "assinatura inválida" é esperada no jwt.io sem a chave pública. A segurança real depende de o servidor validar corretamente a assinatura, o alg e a data de expiração (exp).

### Análise do endpoint: `POST /identity/api/v2/user/reset-password`

Este endpoint é utilizado para validar a identidade de usuário, utilizando o código OTP, que é enviado ao usuário via email para permitir a redefinição da senha.

Foi identificado que o endpoint não possui um bloqueio de tentativaz ou um bloqueio caso tenha múltiplas falhas. Isso possibilita que um atacante possa utilizar a técnica chamada de força bruta, permitindo que o invasor realize várias tentativas em questão de segundos, até que o código seja validado e a senha seja redefinida.

### Análises do endpoint: `POST /identity/api/auth/signup`

Ao analisar o endpoint de cadastro de conta foi possível identificar medidas de segurança ao determinar a senha. Ela deve conter pelo menos um dígito, uma letra minúscula, uma letra maiúscula e um caractere especial. Deve conter pelo menos 8 caracteres e no máximo 16 caracteres. Os caracteres especiais permitidos são #$@!%&*?. A senha dessa forma se mantem segura com essas condições, tornando difícil ser adivinhada por um atacante.

<img width="474" height="470" alt="image" src="https://github.com/user-attachments/assets/6e75bcf5-ee90-415e-aadb-9a052684cbe4" />

---

O endpoint está funcionando normalmente no momento do cadastro, respeitando os requisitos mínimos da senha e também a validação caso o e-mail juntamente com a validação do número de telefone caso já tenha sido utilizado.

<img width="1035" height="603" alt="image" src="https://github.com/user-attachments/assets/f6df7204-f423-4e62-8319-ee2bf8faf55d" />

---

### Análise do endpoint: `POST /workshop/api/merchant/contact_mechanic`

A análise do _endpoint_ de solicitação do mecânico seguiu com a manipulação da funcionalidade com o próprio usuário logado chamado de usuarioum. Logo, foi preenchido os campos Mechanic e Problem Description para o envio da solicição, como ilustrado na imagem abaixo:

<img width="724" height="493" alt="image" src="https://github.com/user-attachments/assets/d2769bb5-4bd3-48ce-9b88-e435d6c237eb" />

Após o envio da solicitação, a requisição foi interceptada no BurpSuite, e em seguida analisada. E identificou-se no _Response_ um link URL de registro da solicitação, e esse registro é classificado por um ID, chamado de report_id.

<img width="1125" height="614" alt="image" src="https://github.com/user-attachments/assets/fb61eb1d-0585-4013-8c5e-fd777099e81c" />

Para entender como é tratado essa URL chamando o ID da solicitação, copiei e colei no campo de URL no navegador. Ao pressionar Enter, para acessar a URL, e na expectativa de retornar os dados do usuário, a API retornou a mensagem "JWT Token requeried!", ou seja, para que o _endpoint_ retorne as informações da solicitação do id=? é necessário o token de autenticação.

<img width="1317" height="396" alt="image" src="https://github.com/user-attachments/assets/2c0943cc-b82e-4ab9-9a82-ae34e0cd906b" />

Por fim, o teste consistiu em realizar uma requisição utilizando o módulo _Repeater_ do BurpSuite, alterando o método para o GET, e passando o JWT do usuárioum (usuário autenticado), para que seja autenticado e retorne as informações da solicitação id=45, como ilustrado abaixo:

<img width="1323" height="584" alt="image" src="https://github.com/user-attachments/assets/e7d4f3df-da30-48dd-980c-4db33180632f" />

A conclusão dessa análise resulta na hipótese de permitir a modificação do id. Como podemos ver acima, o _endpoint_ está retornando as informações do próprio usuário autenticado, se alterarmos o report_id para outro número conseguimos acessar as informções da solicitação de mecânico de outro usuário mesmo utilizando o JWT do usuário atual? Essa tarefa desse teste está presente na fase de exploração.

### Análise do endpoint: `GET /identity/api/v2/vehicle/location`

O _endpoint_ analisado nessa etapa está relacionado a localização do veículo do usuário. Para começar, iniciou a interceptação da requição após a ação no botão "Refresh Location", isso resultou na captura do _endpoint_ e armazenou no BurpSuite para o acesso porterior:

<img width="834" height="595" alt="image" src="https://github.com/user-attachments/assets/5cf83f4b-4698-4d07-86dd-d9c077f7fb6b" />

Em seguida, acessou-se no histórico a requisição, e foi identificado que no _endpoint_ é incluído um id semelhante a um uuid, isso possívelmente é id do príprio veículo do usuário, ou seja, se alterarmos o uuid do veículo conseguimos visualizadr as informações da localização de outro usuário? A fase de ataque, se deu continuidade na fase de exploração.

--- 

### Análise do endpoint: `GET /community/api/v2/community/posts`

A análise desse _endpoint_ encaminhou para interceptação simples. O acesso ao módulo de comunidade foi realizado, posteriormente analisado no histórico no BurpSuite. Ao abrir os dois campos da requisição para iniciar a análise mais detalhada, identificou-se estritamente uma exposição dos dados de outros usuários que postaram seus comentários no campo da comunidade, essa é uma falha crítica, pois expôe informações como: nickname, email e vehicleid. Essa falha de segurança se enquadra na vulnerabilidade mais comum listada pela OWASP chamada de Quebra de Autorização a Nível de Objeto (API1:2023 - BOLA). A exposição dos dados de outro usuário é ilustrado na imagem abaixo:


<img width="1153" height="626" alt="image" src="https://github.com/user-attachments/assets/7e9d4a8c-0e63-4579-ac8c-3f1fc2f4a2ba" />


### Análise do endpoint: `POST /identity/api/auth/v3/check-otp`


